/* scripts/color-lint.js
   Run: node scripts/color-lint.js
   (CommonJS version for direct execution)
*/

const fs = require("fs");
const path = require("path");

const ROOT = process.cwd();

// Configure globs by simple path heuristics (no external deps)
const INCLUDE_EXT = new Set([".ts", ".tsx", ".js", ".jsx", ".css", ".mdx"]);
const EXCLUDE_DIRS = new Set(["node_modules", ".next", "dist", "build", "out", ".git"]);

// Token source exceptions
const TOKEN_FILES_ALLOW_HEX = [
  "COLOR_TOKENS.css",
  "tokens.css", 
  "tokens.scss"
];

const HEX_REGEX = /#[0-9a-fA-F]{3,8}\b/g;

// Direct palette tokens (never in components)
const FORBIDDEN_DIRECT_PALETTE = [
  "var(--cyan-",
  "var(--green-"
];

// "Meaning tokens" that must NOT appear in interaction surfaces
const MEANING_TOKENS_FORBIDDEN_IN_INTERACTION = [
  "var(--semantic-precision",
  "var(--semantic-growth",
  "var(--state-",
  "var(--tint-precision",
  "var(--tint-growth"
];

// Interaction token allowlist
const INTERACTION_TOKENS_ALLOWED = [
  "var(--semantic-accent",
  "var(--semantic-focus-ring",
  "var(--semantic-selection",
  "var(--semantic-text-",
  "var(--semantic-surface-",
  "var(--semantic-border-",
  "var(--neutral-",
  "color-mix("
];

// Path heuristics: "interaction surfaces"
function isInteractionSurface(filePath) {
  const p = filePath.replaceAll("\\", "/").toLowerCase();
  return (
    p.includes("/button") ||
    p.includes("/link") ||
    p.includes("/toggle") ||
    p.includes("/tabs") ||
    p.includes("/nav") ||
    p.includes("/rail") ||
    p.includes("/input") ||
    p.includes("/select") ||
    p.includes("/checkbox") ||
    p.includes("/radio")
  );
}

function shouldSkip(filePath) {
  const base = path.basename(filePath);
  if (TOKEN_FILES_ALLOW_HEX.includes(base)) return true;
  return false;
}

function walk(dir, acc = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    if (EXCLUDE_DIRS.has(e.name)) continue;
    const full = path.join(dir, e.name);
    if (e.isDirectory()) walk(full, acc);
    else {
      const ext = path.extname(full);
      if (INCLUDE_EXT.has(ext)) acc.push(full);
    }
  }
  return acc;
}

function lintFile(file) {
  const rel = path.relative(ROOT, file);
  const text = fs.readFileSync(file, "utf8");
  const lines = text.split(/\r?\n/);

  const violations = [];

  const interaction = isInteractionSurface(rel);

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Rule: no hex in components (except token sources)
    if (!shouldSkip(rel)) {
      const hex = line.match(HEX_REGEX);
      if (hex) {
        violations.push({
          file: rel,
          line: i + 1,
          rule: "Rule C — No raw hex in components",
          detail: `Found hex color(s): ${hex.join(", ")}`
        });
      }
    }

    // Rule: never use direct palette cyan/green tokens in components
    for (const bad of FORBIDDEN_DIRECT_PALETTE) {
      if (line.includes(bad)) {
        violations.push({
          file: rel,
          line: i + 1,
          rule: "Rule B — No direct palette cyan/green usage",
          detail: `Found forbidden token prefix: ${bad} (use semantic tokens instead)`
        });
      }
    }

    if (interaction) {
      // Rule: meaning tokens forbidden in interaction surfaces
      for (const bad of MEANING_TOKENS_FORBIDDEN_IN_INTERACTION) {
        if (line.includes(bad)) {
          violations.push({
            file: rel,
            line: i + 1,
            rule: "Rule A — Interaction cannot use meaning tokens",
            detail: `Found forbidden meaning token: ${bad}`
          });
        }
      }

      // Optional: enforce interaction allowlist
      const usesVar = line.includes("var(--");
      if (usesVar) {
        const ok = INTERACTION_TOKENS_ALLOWED.some((okp) => line.includes(okp));
        if (!ok) {
          violations.push({
            file: rel,
            line: i + 1,
            rule: "Rule A (strict) — Interaction tokens must be semantic",
            detail: `Found token usage not in allowlist. Prefer --semantic-accent/--semantic-focus-ring/--semantic-selection.`
          });
        }
      }
    }
  }

  return violations;
}

function main() {
  const files = walk(ROOT).filter((f) => !f.includes(`${path.sep}node_modules${path.sep}`));
  const all = [];

  for (const f of files) {
    all.push(...lintFile(f));
  }

  if (all.length) {
    console.error(`\n❌ Color lint failed (${all.length} issues)\n`);
    for (const v of all) {
      console.error(`${v.file}:${v.line}`);
      console.error(`  ${v.rule}`);
      console.error(`  ${v.detail}\n`);
    }
    process.exit(1);
  } else {
    console.log("✅ Color lint passed");
  }
}

main();
