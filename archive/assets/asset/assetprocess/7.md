production-ready VideoBackgroundLayer that respects reduced-motion, crossfades between backgrounds, and plugs into PortalSkinProvider via CSS vars + the selected asset set.  
```

// src/portal/VideoBackgroundLayer.tsx
import React, { useEffect, useMemo, useRef, useState } from "react";
import { usePortalSkin } from "./PortalSkinProvider";

/**
 * VideoBackgroundLayer
 * - Uses the currently selected Portal skin background.
 * - If background is video and reduced-motion is NOT enabled, it renders a video loop.
 * - Otherwise it renders nothing (CSS background poster already covers).
 * - Crossfades between background sources.
 *
 * Assumptions:
 * - PortalSkinProvider applies CSS vars and returns skin via usePortalSkin().
 * - selectAssetSet returns background.kind = "video" with poster when motion is allowed.
 */

type Props = {
  className?: string;
  /**
   * Fade duration between backgrounds in ms.
   */
  fadeMs?: number;
  /**
   * If true, will attempt to play audio on the video element (generally false).
   * Keep false for iOS autoplay policies.
   */
  allowAudio?: boolean;
  /**
   * Force disable video rendering regardless of skin.
   */
  forcePosterOnly?: boolean;
};

type Layer = {
  id: string;
  src: string;
  type: string;
  poster?: string;
};

function isVideoType(mime: string) {
  return mime.startsWith("video/");
}

function uid() {
  return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

/**
 * A tiny heuristic for reduced motion:
 * - PortalSkinProvider already selected poster-only if reduced-motion was enabled.
 * - Here, we treat "video with no poster and no autoplay" cautiously.
 */
function shouldRenderVideo(params: {
  forcePosterOnly?: boolean;
  bg?: { kind: string; src: string; type: string; poster?: { src: string } | undefined } | null;
}) {
  const { forcePosterOnly, bg } = params;
  if (forcePosterOnly) return false;
  if (!bg) return false;
  if (bg.kind !== "video") return false;
  if (!bg.src || !bg.type) return false;
  if (!isVideoType(bg.type)) return false;
  return true;
}

export function VideoBackgroundLayer({ className, fadeMs = 420, allowAudio = false, forcePosterOnly = false }: Props) {
  const { status, skin } = usePortalSkin();

  const bg = skin?.background ?? null;

  const nextLayer: Layer | null = useMemo(() => {
    if (!shouldRenderVideo({ forcePosterOnly, bg })) return null;
    return {
      id: uid(),
      src: bg!.src,
      type: bg!.type,
      poster: bg!.poster?.src,
    };
  }, [bg?.kind, bg?.src, bg?.type, bg?.poster?.src, forcePosterOnly]);

  const [layers, setLayers] = useState<Layer[]>([]);
  const activeIdRef = useRef<string | null>(null);

  useEffect(() => {
    if (status !== "ready") return;

    // If no video to render, clear layers.
    if (!nextLayer) {
      setLayers([]);
      activeIdRef.current = null;
      return;
    }

    // If already active and same src, do nothing.
    if (activeIdRef.current) {
      const current = layers.find((l) => l.id === activeIdRef.current);
      if (current?.src === nextLayer.src) return;
    }

    // Add new layer, keep old for crossfade.
    setLayers((prev) => {
      const keep = prev.slice(-1); // keep only the most recent (if any)
      return [...keep, nextLayer];
    });

    // Mark new active
    activeIdRef.current = nextLayer.id;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [status, nextLayer?.src]);

  // Cleanup old layer after fade
  useEffect(() => {
    if (layers.length <= 1) return;
    const t = window.setTimeout(() => {
      setLayers((prev) => prev.slice(-1));
    }, fadeMs + 50);
    return () => window.clearTimeout(t);
  }, [layers.length, fadeMs]);

  if (status !== "ready") return null;
  if (!nextLayer) return null;

  return (
    <div
      className={className}
      style={{
        position: "absolute",
        inset: 0,
        overflow: "hidden",
        pointerEvents: "none",
        zIndex: 0,
      }}
      aria-hidden="true"
    >
      {layers.map((layer, idx) => {
        const isTop = idx === layers.length - 1;
        return (
          <VideoLayer
            key={layer.id}
            layer={layer}
            isTop={isTop}
            fadeMs={fadeMs}
            allowAudio={allowAudio}
          />
        );
      })}
    </div>
  );
}

function VideoLayer({
  layer,
  isTop,
  fadeMs,
  allowAudio,
}: {
  layer: Layer;
  isTop: boolean;
  fadeMs: number;
  allowAudio: boolean;
}) {
  const videoRef = useRef<HTMLVideoElement | null>(null);
  const [ready, setReady] = useState(false);

  useEffect(() => {
    const v = videoRef.current;
    if (!v) return;

    const onCanPlay = () => setReady(true);
    v.addEventListener("canplay", onCanPlay);

    // Try to play; autoplay policies may block, but it still serves as background.
    const tryPlay = async () => {
      try {
        await v.play();
      } catch {
        // Autoplay might be blocked; that's okay.
      }
    };
    tryPlay();

    return () => {
      v.removeEventListener("canplay", onCanPlay);
    };
  }, [layer.src]);

  return (
    <video
      ref={videoRef}
      playsInline
      muted={!allowAudio}
      loop
      autoPlay
      preload="metadata"
      poster={layer.poster}
      style={{
        position: "absolute",
        inset: 0,
        width: "100%",
        height: "100%",
        objectFit: "cover",
        transition: `opacity ${fadeMs}ms ease`,
        opacity: isTop ? (ready ? 1 : 0) : 0,
        filter: "saturate(1) contrast(1)",
        transform: "translateZ(0)",
      }}
    >
      {/* Source typed for Safari/Chromium selection */}
      <source src={layer.src} type={layer.type} />
    </video>
  );
}

```
# **How to wire it in (PortalShell layout)**  
```

import { PortalSkinProvider } from "@/portal/PortalSkinProvider";
import { VideoBackgroundLayer } from "@/portal/VideoBackgroundLayer";

export function PortalShell({ registry, children }: { registry: any; children: React.ReactNode }) {
  return (
    <PortalSkinProvider
      config={{
        registry,
        surface: "cmp_portal_shell",
        lens: "individual",
        intent: "portal_shell",
        schemaIds: ["schema_real_life_run"],
      }}
      className="portal-skin relative min-h-screen"
    >
      <VideoBackgroundLayer className="absolute inset-0" fadeMs={520} />
      {/* Your actual UI sits above */}
      <div className="relative z-10">{children}</div>
    </PortalSkinProvider>
  );
}

```
## **Notes (practical)**  
* This component renders **only** when the selected skin background is a video.  
* When reduced-motion is enabled, selectAssetSet() should already return a poster, so this layer auto-disables.  
* Crossfade uses “two layers max” to stay cheap.  
