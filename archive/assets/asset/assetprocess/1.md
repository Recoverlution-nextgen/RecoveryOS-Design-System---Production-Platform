Yes — if this is going to be **universal** (marketing + platform + internal tooling), then the asset system has to model **the whole OS**, not just the website.  
Your anchor doc already defines the platform reality: LUMA as orchestrator, rooms (Journeys, NaviCues, Toolkit, Wellbeing, State), the universal Player, Trust/Safety rails, Integrations, and the three altitudes (Companion / Console / Command Center).  
RecoveryOS 2e25a0fd01ef803b9f50…  
 So the asset system must be able to serve **every surface** that those rooms appear in.  
Below is the “everything you’ll need” spec your devs can script end-to-end.  
  
## **1) The universal model: “assets are tokens, renditions are files”**  
## **Core rule**  
* **Asset IDs are stable forever.**  
* Canva names can change; the **ID doesn’t**. (Matches your governance principle: “Labels evolve. IDs don’t.”) RecoveryOS 2e25a0fd01ef803b9f50…   
## **One registry, many surfaces**  
* Marketing site (keynote hero, page sections, diagrams)  
* Platform UI (Player backgrounds, feed cards, proof vault textures, state visuals)  
* Console / Command Center (dashboard visuals, integrity log motifs)  
* Emails/PDF specs (exported from same sources)  
  
## **2) Expand the taxonomy to include the full platform**  
Your existing taxonomy is strong. To cover “everything,” add two missing axes:  
## **A) Surfaces (where assets are used)**  
These map directly to your OS rooms + three worlds:  
* **Marketing**  
    * mkt_home, mkt_how_it_works, mkt_trust, mkt_three_worlds, mkt_specs, mkt_contact  
* **Companion (Individual)**  
    * cmp_journeys, cmp_navicues_feed, cmp_toolkit, cmp_wellbeing, cmp_state, cmp_player, cmp_luma_play, cmp_luma_talk, cmp_proof_vault  
* **Console (Professional)**  
    * con_case_feed, con_timeline, con_signal_panels, con_trace_travel, con_integrity_log  
* **Command Center (Org)**  
    * cc_system_dashboard, cc_governance, cc_audit, cc_momentum_curves, cc_escalation_protocols  
* **System layers**  
    * sys_trust_rails, sys_consent_map, sys_quiet_hours, sys_escalation, sys_integrations  
This matches the doc’s rooms + altitudes (Companion / Console / Command Center) and your Trust/Governance emphasis.  
RecoveryOS 2e25a0fd01ef803b9f50…  
## **B) Roles of an asset (what job it’s doing)**  
Your asset_classes are good but a bit marketing-weighted. Add these so platform UI isn’t forced into “hero/system/proof”:  
* atmosphere (ambient fields, cinematic layers)  
* hero (keynote scenes)  
* system (maps, diagrams, “spine visuals”)  
* proof (receipt textures, seal marks, vault backplates)  
* icon  
* ui_texture (glass grain, noise overlays, gradients, frames)  
* ui_illustration (micro diagrams / explanatory)  
* motion_loop (webm/mp4 loop + poster)  
* audio_bed (your OS sound beds: route/engage/seal)  
* lottie (optional for micro motion if you use it)  
  
## **3) Canva reality check (important for your devs)**  
## **Canva Connect exports (scripted)**  
Connect exports support: pdf, jpg, png, gif, pptx, mp4.  So:  
* Canva → exports PNG/JPG/MP4  
* Your pipeline → transcodes to AVIF/WEBP/WEBM  
## **Export formats discovery per design**  
You can ask Canva what formats a design supports: GET /designs/{designId}/export-formats.  
## **Folder automation exists**  
You can programmatically create folders (root/uploads/parent): POST /folders.  
## **Tags exist (on assets)**  
You can update asset tags; **updating replaces all existing tags** (important for scripting).  
## **Webhooks can be verified with Canva JWK keys endpoint**  
Keys API returns JWK for webhook verification.  
  
## **4) The end-to-end system you want (scriptable)**  
## **A) Canva is your design source + rendition factory**  
* Folders = truthy classification (room/class)  
* Names = stable IDs + metadata encoding  
* (Optional) tags on Canva assets for human search  
## **B) Your pipeline is the truth layer**  
* Registry (Postgres or versioned JSON)  
* Storage (Supabase or R2)  
* Selector logic (frontend + platform)  
## **C) Script responsibilities**  
1. Create/validate Canva folder tree  
2. Scan “Production” folders  
3. Parse naming convention  
4. Export designs (PNG/JPG/MP4) via Connect  
5. Transcode:  
    * image → avif + webp  
    * video → webm + mp4 + poster image  
6. Upload to storage  
7. Update registry entries + renditions + budgets  
8. Mark deprecations & tombstones  
9. Emit build-friendly registry snapshot for marketing  
  
## **5) Naming convention that works for *marketing + platform***  
Use one stable grammar everywhere:  
**Design name format**  
```

{surface}__{asset_class}__{asset_id}__{aspect}__v{n}

```
Examples:  
* mkt_home__hero__hero_recoveryos_field_001__21x9__v3  
* cmp_player__atmosphere__atmo_field_base_004__16x9__v1  
* con_timeline__system__system_continuity_chain_002__16x9__v2  
* cmp_proof_vault__proof__proof_receipt_texture_008__1x1__v4  
This gives you:  
* deterministic parsing  
* deterministic placement defaults  
* no guessing on the frontend  
  
## **6) The “cover every scenario” registry schema**  
This is the part your devs will love: **exact JSON-like schema** (expanded to platform).  
## ****asset-registry.schema.json (conceptual)****  
```

{
  "version": "2.0.0",
  "kinds": ["image", "video", "audio", "pdf", "other"],

  "taxonomies": {
    "asset_classes": [
      "atmosphere",
      "hero",
      "system",
      "proof",
      "icon",
      "ui_texture",
      "ui_illustration",
      "motion_loop",
      "audio_bed"
    ],
    "aspect_rails": ["21:9", "16:9", "2:1", "4:5", "1:1", "9:16"],
    "lenses": ["individual", "professional", "organisation"],
    "altitudes": ["companion", "console", "command_center"],
    "rooms": ["journeys", "navicues", "toolkit", "wellbeing", "state", "library", "dashboard", "trust", "integrations"],
    "surfaces": [
      "mkt_home", "mkt_how_it_works", "mkt_trust", "mkt_three_worlds", "mkt_specs", "mkt_contact",
      "cmp_journeys", "cmp_navicues_feed", "cmp_toolkit", "cmp_wellbeing", "cmp_state", "cmp_player", "cmp_luma_play", "cmp_luma_talk", "cmp_proof_vault",
      "con_case_feed", "con_timeline", "con_signal_panels", "con_trace_travel", "con_integrity_log",
      "cc_system_dashboard", "cc_governance", "cc_audit", "cc_momentum_curves", "cc_escalation_protocols",
      "sys_trust_rails", "sys_consent_map", "sys_quiet_hours", "sys_escalation", "sys_integrations"
    ]
  },

  "governance": {
    "ids_are_stable": true,
    "labels_are_synonyms_only": true,
    "approval_states": ["draft", "review", "approved", "deprecated", "blocked"],
    "locked_domains": {
      "pillars": [
        { "id": "pillar_ER", "labels": ["Emotional Regulation", "ER"] },
        { "id": "pillar_SR", "labels": ["Stress Resilience", "SR"] },
        { "id": "pillar_SC", "labels": ["Social Connectivity", "SC"] },
        { "id": "pillar_CR", "labels": ["Cognitive Reframing", "CR"] },
        { "id": "pillar_II", "labels": ["Identity Integration", "II"] },
        { "id": "pillar_DM", "labels": ["Decision Mastery", "DM"] }
      ]
    }
  },

  "budgets": {
    "image": {
      "hero_poster_kb_max": 400,
      "section_poster_kb_max": 200,
      "card_kb_max": 120,
      "primary": "avif",
      "fallback": "webp"
    },
    "video": {
      "hero_loop_mb_max": 1.8,
      "micro_loop_kb_max": 600,
      "duration_s_range": [8, 12],
      "primary": "webm",
      "fallback": "mp4",
      "reduce_motion_policy": "poster_only"
    }
  },

  "assets": [
    {
      "id": "hero_recoveryos_field_001",
      "kind": "image",
      "asset_class": "hero",
      "status": "approved",

      "source": {
        "type": "canva",
        "design_id": "DAFxxxx",
        "design_name": "mkt_home__hero__hero_recoveryos_field_001__21x9__v3",
        "exported_at": "2026-01-10T12:00:00Z"
      },

      "fit": {
        "surfaces": ["mkt_home"],
        "rooms": ["library"],
        "lenses": ["individual", "professional", "organisation"],
        "altitudes": ["companion", "console", "command_center"],
        "component_fit": ["WalkthroughPresenter", "PortalShell"],
        "schema_ids": ["schema_real_life_run"],
        "proof_fit": []
      },

      "placement": {
        "safe_area": { "top": 0.08, "right": 0.08, "bottom": 0.12, "left": 0.08 },
        "focal_point": { "x": 0.52, "y": 0.44 }
      },

      "accessibility": {
        "alt": "Abstract cinematic field expressing continuity and calm motion.",
        "decorative_ok": true
      },

      "renditions": [
        {
          "format": "avif",
          "aspect": "21:9",
          "width": 2560,
          "bytes": 312000,
          "url": "https://cdn.../assets/hero_recoveryos_field_001/21x9/2560.avif",
          "sha256": "..."
        },
        {
          "format": "webp",
          "aspect": "21:9",
          "width": 2560,
          "bytes": 420000,
          "url": "https://cdn.../assets/hero_recoveryos_field_001/21x9/2560.webp",
          "sha256": "..."
        }
      ],

      "license": {
        "kind": "owned",
        "notes": "Original studio asset. No third-party restrictions."
      }
    }
  ]
}

```
## **Why these fields matter (every scenario coverage)**  
* **surfaces** solves “marketing + platform” immediately.  
* **status** solves governance (“draft vs approved vs deprecated”).  
* **accessibility** solves alt-text / decorative policy.  
* **license** solves real-world legal drift.  
* **placement.safe_area/focal_point** solves “hero cropping always looks right.”  
* **renditions[]** solves performance + responsive.  
  
## **7) Storage strategy (universal + future-proof)**  
You can keep Supabase. Just organize like an OS:  
## **Buckets**  
* public-site (marketing, immutable)  
* public-shared (shared decorative textures used anywhere)  
* private-platform (signed URLs / RLS)  
## **Path convention**  
```

/assets/{asset_id}/{aspect}/{width}.{ext}

```
## **Cache behavior**  
* Versioned filenames → Cache-Control: public, max-age=31536000, immutable  
* Registry JSON (if public) → shorter cache (e.g., 5–15 minutes) or version it too.  
  
## **8) Canva automation “setup in my Canva account” (what’s real)**  
Your devs can absolutely run a script that:  
* creates the full folder tree via Connect (POST /folders)   
* scans production folders  
* exports designs to supported formats (PNG/JPG/MP4 etc.)   
* optionally tags assets (knowing tags replace existing tags)   
* listens to webhooks and verifies signatures via JWK keys   
It’s not “code installed inside Canva,” it’s an **integration authorized on your Canva account** that manipulates your Canva library and runs the pipeline.  
  
## **9) The missing “platform coverage” piece: audio + motion as first-class assets**  
Your OS already uses:  
* route/engage/seal audio beds (you’ve wired that in earlier)  
* motion policy (reduced motion)  
* the universal Player (everything runs through it) RecoveryOS 2e25a0fd01ef803b9f50…   
So the asset system must support:  
* audio_bed assets (mp3/ogg/wav variants, low-latency)  
* motion_loop assets (webm + mp4 + poster + reduce-motion behavior)  
* “player skins” (ui_texture overlays, vignettes, grain)  
Add these to the registry and the pipeline now, so you don’t retrofit later.  
  
## **10) “Everything they will script” — deliverables checklist**  
## **Canva side**  
* Create folder tree  
* Enforce naming convention  
* (Optional) Tag assets for human search  
* Export pipeline (async jobs)   
* Webhooks (optional)   
## **Pipeline side**  
* Transcode images → AVIF+WEBP  
* Transcode video → WEBM+MP4 + poster  
* Budget validator (fail build if oversized)  
* Upload to Supabase buckets  
* Write/Upsert registry rows  
* Generate marketing snapshot JSON for frontend  
## **Frontend/platform side**  
* selectAsset() selector (by surface + component + lens + aspect + budgets)  
* reduced-motion enforcement (poster-only)  
* fallback chain (avif → webp)  
* “decorative_ok” + alt enforcement  
