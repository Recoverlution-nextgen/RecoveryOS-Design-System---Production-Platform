production-ready selectAsset() (TypeScript) that consumes the registry + mappings, enforces budgets + reduced-motion, and returns src/srcSet, poster, MIME type, and preload hints.  
```

// src/assets/selectAsset.ts
import {
  ASSET_CLASS_BY_COMPONENT,
  COMPONENT_DEFAULTS,
  SURFACE_DEFAULTS,
  ASPECT_PRIORITY_BY_SURFACE,
  type Aspect,
  type AssetClass,
  type Lens,
  type Surface,
} from "./mappings";

/**
 * Registry types (minimal but complete for selection).
 */
export type AssetStatus = "draft" | "review" | "approved" | "deprecated" | "blocked";

export type Rendition = {
  format: "avif" | "webp" | "jpg" | "png" | "webm" | "mp4" | "mp3" | "ogg" | "pdf";
  aspect?: Aspect;        // images/video
  width?: number;         // images/video
  bytes: number;
  url: string;
  sha256?: string;
};

export type Asset = {
  id: string;
  kind: "image" | "video" | "audio" | "pdf" | "other";
  asset_class: AssetClass;
  status: AssetStatus;

  // Optional but useful
  accessibility?: { alt?: string; decorative_ok?: boolean };

  fit?: {
    surfaces?: Surface[];
    rooms?: string[];
    lenses?: Lens[];
    altitudes?: string[];
    component_fit?: string[];
    schema_ids?: string[];
    pillar_ids?: string[];
    proof_fit?: string[];
  };

  motion?: {
    autoplay_default?: boolean;
    reduce_motion_policy?: "poster_only" | "no_autoplay" | "allow";
    duration_s?: number;
  };

  renditions: Rendition[];
};

export type AssetRegistry = {
  version: string;
  budgets?: {
    image?: {
      hero_poster_kb_max?: number;
      section_poster_kb_max?: number;
      card_kb_max?: number;
      primary?: "avif";
      fallback?: "webp";
    };
    video?: {
      hero_loop_mb_max?: number;
      micro_loop_kb_max?: number;
      duration_s_range?: [number, number];
      primary?: "webm";
      fallback?: "mp4";
      reduce_motion_policy?: "poster_only";
    };
    audio?: {
      bed_kb_max?: number;
      formats?: Array<"mp3" | "ogg">;
      loop?: boolean;
    };
  };
  assets: Asset[];
};

export type SelectAssetInput = {
  registry: AssetRegistry;

  surface: Surface;
  component: string;

  // Optional intent signals
  lens?: Lens;
  assetClassOverride?: AssetClass;
  schemaIds?: string[];
  pillarIds?: string[];
  proofFit?: string[];

  // Rendering constraints
  preferAspect?: Aspect;
  maxWidth?: number; // target width in px for choosing best rendition
  prefersReducedMotion?: boolean;
  allowMotion?: boolean; // overrides surface defaults
  allowDeprecated?: boolean;

  // if you need audio selection too
  kind?: "image" | "video" | "audio";
};

export type SelectedAsset = {
  assetId: string;
  kind: "image" | "video" | "audio";
  asset_class: AssetClass;

  // Render payload
  src: string;
  type: string; // MIME type
  srcSet?: string;
  sizes?: string;

  // For videos / motion
  poster?: { src: string; type: string };
  autoplay?: boolean;

  // Accessibility
  alt?: string;
  decorative_ok?: boolean;

  // Useful extras
  preload?: Array<{ as: "image" | "video" | "audio"; href: string; type: string }>;
  warnings: string[];

  // Debug (optional; keep for dev)
  debug?: {
    chosenAspect?: Aspect;
    chosenWidth?: number;
    candidatesConsidered: number;
  };
};

function mimeFor(format: Rendition["format"]) {
  switch (format) {
    case "avif":
      return "image/avif";
    case "webp":
      return "image/webp";
    case "jpg":
      return "image/jpeg";
    case "png":
      return "image/png";
    case "webm":
      return "video/webm";
    case "mp4":
      return "video/mp4";
    case "mp3":
      return "audio/mpeg";
    case "ogg":
      return "audio/ogg";
    case "pdf":
      return "application/pdf";
    default:
      return "application/octet-stream";
  }
}

function bytesToKB(bytes: number) {
  return bytes / 1024;
}

function bytesToMB(bytes: number) {
  return bytes / (1024 * 1024);
}

function uniq<T>(arr: T[]) {
  return Array.from(new Set(arr));
}

function includesAny(hay?: string[], needles?: string[]) {
  if (!hay || !needles || needles.length === 0) return false;
  const set = new Set(hay);
  return needles.some((n) => set.has(n));
}

function scoreAsset(asset: Asset, input: SelectAssetInput): number {
  // Higher is better
  let score = 0;

  // Status weight
  if (asset.status === "approved") score += 30;
  else if (asset.status === "review") score += 10;
  else if (asset.status === "draft") score -= 5;
  else if (asset.status === "deprecated") score -= 15;
  else if (asset.status === "blocked") score -= 1000;

  // Surface fit
  if (asset.fit?.surfaces?.includes(input.surface)) score += 20;

  // Component fit
  if (asset.fit?.component_fit?.includes(input.component)) score += 22;

  // Lens fit
  if (input.lens && asset.fit?.lenses?.includes(input.lens)) score += 10;

  // Schema relevance
  if (includesAny(asset.fit?.schema_ids, input.schemaIds)) score += 8;

  // Pillar relevance
  if (includesAny(asset.fit?.pillar_ids, input.pillarIds)) score += 6;

  // Proof fit
  if (includesAny(asset.fit?.proof_fit, input.proofFit)) score += 6;

  // Mild preference: assets with explicit fit metadata
  if (asset.fit) score += 2;

  return score;
}

function pickAspectOrder(input: SelectAssetInput): Aspect[] {
  const bySurface = ASPECT_PRIORITY_BY_SURFACE[input.surface] ?? (["16:9", "2:1", "21:9"] as Aspect[]);
  const byComponent = COMPONENT_DEFAULTS[input.component]?.preferred_aspects ?? [];
  const prefer = input.preferAspect ? [input.preferAspect] : [];

  // Merge order: explicit prefer → component → surface
  return uniq([...(prefer as Aspect[]), ...(byComponent as Aspect[]), ...(bySurface as Aspect[])]);
}

function pickRenditionsForKind(asset: Asset, kind: "image" | "video" | "audio") {
  if (kind === "image") return asset.renditions.filter((r) => ["avif", "webp", "jpg", "png"].includes(r.format));
  if (kind === "video") return asset.renditions.filter((r) => ["webm", "mp4"].includes(r.format));
  if (kind === "audio") return asset.renditions.filter((r) => ["mp3", "ogg"].includes(r.format));
  return [];
}

function chooseBestWidth(target?: number, widths?: number[]) {
  if (!widths || widths.length === 0) return undefined;
  const sorted = [...widths].sort((a, b) => a - b);
  if (!target) return sorted[sorted.length - 1]; // largest
  // choose the smallest width >= target, else the largest
  for (const w of sorted) if (w >= target) return w;
  return sorted[sorted.length - 1];
}

function budgetWarn(input: SelectAssetInput, asset: Asset, rendition: Rendition): string[] {
  const warnings: string[] = [];
  const budgets = input.registry.budgets;

  // Simple heuristic: infer "hero/section/card" by component default or aspect
  const compDefaults = COMPONENT_DEFAULTS[input.component];
  const cls = asset.asset_class;

  if (asset.kind === "image") {
    const kb = bytesToKB(rendition.bytes);

    // if hero class or uses 21:9, apply hero budget
    const heroMax = budgets?.image?.hero_poster_kb_max ?? 400;
    const sectionMax = budgets?.image?.section_poster_kb_max ?? 200;
    const cardMax = budgets?.image?.card_kb_max ?? 120;

    if (cls === "hero" || rendition.aspect === "21:9") {
      if (kb > heroMax) warnings.push(`Hero image over budget: ${Math.round(kb)}KB > ${heroMax}KB.`);
    } else if (rendition.aspect === "1:1" || rendition.aspect === "4:5") {
      if (kb > cardMax) warnings.push(`Card image over budget: ${Math.round(kb)}KB > ${cardMax}KB.`);
    } else {
      if (kb > sectionMax) warnings.push(`Section image over budget: ${Math.round(kb)}KB > ${sectionMax}KB.`);
    }
  }

  if (asset.kind === "video") {
    const mb = bytesToMB(rendition.bytes);
    const heroMax = budgets?.video?.hero_loop_mb_max ?? 1.8;
    const microMax = (budgets?.video?.micro_loop_kb_max ?? 600) / 1024;

    // Treat WalkthroughPresenter/AmbientField as hero-like
    const heroLike = input.component === "WalkthroughPresenter" || input.component === "AmbientField" || cls === "motion_loop";

    if (heroLike) {
      if (mb > heroMax) warnings.push(`Hero loop over budget: ${mb.toFixed(2)}MB > ${heroMax}MB.`);
    } else {
      if (mb > microMax) warnings.push(`Micro loop over budget: ${mb.toFixed(2)}MB > ${microMax.toFixed(2)}MB.`);
    }
  }

  if (asset.kind === "audio") {
    const kb = bytesToKB(rendition.bytes);
    const max = input.registry.budgets?.audio?.bed_kb_max ?? 900;
    if (kb > max) warnings.push(`Audio bed over budget: ${Math.round(kb)}KB > ${max}KB.`);
  }

  // Reduced motion rule
  if (input.prefersReducedMotion && asset.kind === "video") {
    warnings.push(`Reduced motion enabled: video suppressed (poster-only).`);
  }

  return warnings;
}

/**
 * MAIN: selectAsset()
 * - Filters by surface/component/class/lens
 * - Scores candidates by fit + status + relevance
 * - Picks best aspect rail + best width
 * - Returns src/srcSet/poster + preload hints + warnings
 */
export function selectAsset(input: SelectAssetInput): SelectedAsset | null {
  const warnings: string[] = [];

  const surfaceDefaults = SURFACE_DEFAULTS[input.surface];
  const allowMotion = input.allowMotion ?? surfaceDefaults?.motion_ok ?? false;

  // Determine desired class
  const desiredClass: AssetClass =
    input.assetClassOverride ??
    COMPONENT_DEFAULTS[input.component]?.asset_class ??
    ASSET_CLASS_BY_COMPONENT[input.component] ??
    "system";

  // Determine desired kind
  const desiredKind: "image" | "video" | "audio" =
    input.kind ??
    (desiredClass === "audio_bed"
      ? "audio"
      : desiredClass === "motion_loop"
        ? "video"
        : "image");

  // Determine aspect order
  const aspectOrder = pickAspectOrder(input);

  // Filter candidates
  const candidates = input.registry.assets
    .filter((a) => a.kind === desiredKind)
    .filter((a) => (surfaceDefaults?.allowed_classes?.length ? surfaceDefaults.allowed_classes.includes(a.asset_class) : true))
    .filter((a) => a.asset_class === desiredClass || (desiredClass === "atmosphere" && a.asset_class === "motion_loop") ? true : a.asset_class === desiredClass)
    .filter((a) => (input.allowDeprecated ? true : a.status !== "deprecated"))
    .filter((a) => a.status !== "blocked")
    .filter((a) => {
      // Surface and component filtering: if fit is specified, enforce it; if absent, allow.
      const surfaces = a.fit?.surfaces;
      const components = a.fit?.component_fit;
      if (surfaces && surfaces.length && !surfaces.includes(input.surface)) return false;
      if (components && components.length && !components.includes(input.component)) return false;
      return true;
    })
    .filter((a) => {
      if (!input.lens) return true;
      const lenses = a.fit?.lenses;
      if (lenses && lenses.length) return lenses.includes(input.lens);
      return true;
    });

  if (candidates.length === 0) return null;

  // Score candidates
  const scored = candidates
    .map((a) => ({ a, score: scoreAsset(a, input) }))
    .sort((x, y) => y.score - x.score);

  // Decide motion policy for videos
  const prefersReducedMotion = Boolean(input.prefersReducedMotion);
  const motionSuppressed = prefersReducedMotion || !allowMotion;

  // Choose the top candidate that can satisfy aspect+format constraints
  for (const { a: asset } of scored) {
    if (desiredKind === "audio") {
      const audioR = pickRenditionsForKind(asset, "audio");
      // prefer ogg, then mp3 for web
      const best = audioR.find((r) => r.format === "ogg") ?? audioR.find((r) => r.format === "mp3") ?? audioR[0];
      if (!best) continue;

      warnings.push(...budgetWarn(input, asset, best));

      return {
        assetId: asset.id,
        kind: "audio",
        asset_class: asset.asset_class,
        src: best.url,
        type: mimeFor(best.format),
        preload: [{ as: "audio", href: best.url, type: mimeFor(best.format) }],
        warnings,
        debug: { candidatesConsidered: candidates.length },
      };
    }

    if (desiredKind === "video") {
      // If motion suppressed, try to find poster (avif/webp/png/jpg) in renditions
      if (motionSuppressed) {
        const poster =
          asset.renditions.find((r) => ["avif", "webp", "jpg", "png"].includes(r.format) && (!r.aspect || r.aspect === (input.preferAspect ?? "16:9"))) ??
          asset.renditions.find((r) => ["avif", "webp", "jpg", "png"].includes(r.format));

        if (!poster) continue;

        warnings.push(...budgetWarn(input, asset, poster));

        return {
          assetId: asset.id,
          kind: "video",
          asset_class: asset.asset_class,
          src: poster.url,
          type: mimeFor(poster.format),
          poster: { src: poster.url, type: mimeFor(poster.format) },
          autoplay: false,
          preload: [{ as: "image", href: poster.url, type: mimeFor(poster.format) }],
          warnings,
          debug: { chosenAspect: poster.aspect, chosenWidth: poster.width, candidatesConsidered: candidates.length },
        };
      }

      // Motion allowed: pick best webm/mp4 by aspect rail and width
      const vids = pickRenditionsForKind(asset, "video");

      // find a poster if present
      const poster =
        asset.renditions.find((r) => ["avif", "webp", "jpg", "png"].includes(r.format) && r.aspect && aspectOrder.includes(r.aspect)) ??
        asset.renditions.find((r) => ["avif", "webp", "jpg", "png"].includes(r.format));

      for (const aspect of aspectOrder) {
        const aspectVids = vids.filter((r) => r.aspect === aspect);
        if (aspectVids.length === 0) continue;

        const widths = aspectVids.map((r) => r.width).filter((w): w is number => typeof w === "number");
        const bestW = chooseBestWidth(input.maxWidth, widths);

        // prefer webm then mp4 at chosen width
        const atW = bestW ? aspectVids.filter((r) => r.width === bestW) : aspectVids;
        const best = atW.find((r) => r.format === "webm") ?? atW.find((r) => r.format === "mp4") ?? atW[0];
        if (!best) continue;

        warnings.push(...budgetWarn(input, asset, best));

        const preload: SelectedAsset["preload"] = [{ as: "video", href: best.url, type: mimeFor(best.format) }];
        if (poster) preload.unshift({ as: "image", href: poster.url, type: mimeFor(poster.format) });

        return {
          assetId: asset.id,
          kind: "video",
          asset_class: asset.asset_class,
          src: best.url,
          type: mimeFor(best.format),
          poster: poster ? { src: poster.url, type: mimeFor(poster.format) } : undefined,
          autoplay: asset.motion?.autoplay_default ?? true,
          preload,
          warnings,
          debug: { chosenAspect: aspect, chosenWidth: bestW, candidatesConsidered: candidates.length },
        };
      }

      // fallback: any video
      const best = vids.find((r) => r.format === "webm") ?? vids.find((r) => r.format === "mp4") ?? vids[0];
      if (!best) continue;

      warnings.push(...budgetWarn(input, asset, best));

      return {
        assetId: asset.id,
        kind: "video",
        asset_class: asset.asset_class,
        src: best.url,
        type: mimeFor(best.format),
        autoplay: asset.motion?.autoplay_default ?? true,
        warnings,
        debug: { candidatesConsidered: candidates.length },
      };
    }

    // desiredKind === "image"
    const imgs = pickRenditionsForKind(asset, "image");

    // Try aspects in order; for each aspect, pick best width and prefer avif then webp
    for (const aspect of aspectOrder) {
      const aspectImgs = imgs.filter((r) => r.aspect === aspect);
      if (aspectImgs.length === 0) continue;

      const widths = aspectImgs.map((r) => r.width).filter((w): w is number => typeof w === "number");
      const bestW = chooseBestWidth(input.maxWidth, widths);

      const atW = bestW ? aspectImgs.filter((r) => r.width === bestW) : aspectImgs;
      const best = atW.find((r) => r.format === "avif") ?? atW.find((r) => r.format === "webp") ?? atW[0];
      if (!best) continue;

      // Build srcset from same aspect and same format family (avif primary else webp)
      const preferFormat = best.format === "avif" ? "avif" : best.format === "webp" ? "webp" : best.format;
      const srcsetCandidates = aspectImgs
        .filter((r) => r.format === preferFormat && typeof r.width === "number")
        .sort((a, b) => (a.width ?? 0) - (b.width ?? 0));

      const srcSet =
        srcsetCandidates.length >= 2
          ? srcsetCandidates.map((r) => `${r.url} ${r.width}w`).join(", ")
          : undefined;

      // Default sizes: safe + generic; override in callsite if needed
      const sizes = input.maxWidth
        ? `(max-width: 768px) 100vw, ${Math.min(input.maxWidth, 1200)}px`
        : `(max-width: 768px) 100vw, 1200px`;

      warnings.push(...budgetWarn(input, asset, best));

      const preload: SelectedAsset["preload"] = [{ as: "image", href: best.url, type: mimeFor(best.format) }];

      return {
        assetId: asset.id,
        kind: "image",
        asset_class: asset.asset_class,
        src: best.url,
        type: mimeFor(best.format),
        srcSet,
        sizes,
        alt: asset.accessibility?.alt,
        decorative_ok: asset.accessibility?.decorative_ok,
        preload,
        warnings,
        debug: { chosenAspect: aspect, chosenWidth: bestW, candidatesConsidered: candidates.length },
      };
    }

    // Fallback: any image rendition
    const best = imgs.find((r) => r.format === "avif") ?? imgs.find((r) => r.format === "webp") ?? imgs[0];
    if (!best) continue;

    warnings.push(...budgetWarn(input, asset, best));

    return {
      assetId: asset.id,
      kind: "image",
      asset_class: asset.asset_class,
      src: best.url,
      type: mimeFor(best.format),
      alt: asset.accessibility?.alt,
      decorative_ok: asset.accessibility?.decorative_ok,
      preload: [{ as: "image", href: best.url, type: mimeFor(best.format) }],
      warnings,
      debug: { candidatesConsidered: candidates.length },
    };
  }

  return null;
}

```
  
# **Quick usage examples**  
## **1) Marketing hero (keynote)**  
```

const selected = selectAsset({
  registry,
  surface: "mkt_home",
  component: "WalkthroughPresenter",
  lens: "individual",
  maxWidth: 1920,
  prefersReducedMotion: false,
  schemaIds: ["schema_real_life_run"],
});

```
## **2) Companion player ambient loop (respects reduced motion)**  
```

const ambient = selectAsset({
  registry,
  surface: "cmp_player",
  component: "UniversalPlayer",
  assetClassOverride: "motion_loop",
  maxWidth: 1920,
  prefersReducedMotion: window.matchMedia("(prefers-reduced-motion: reduce)").matches,
});

```
## **3) Proof vault textures**  
```

const proofTex = selectAsset({
  registry,
  surface: "cmp_proof_vault",
  component: "ProofVaultGrid",
  maxWidth: 1024,
  schemaIds: ["schema_proof_capture"],
  proofFit: ["receipt_ready"],
  prefersReducedMotion: true,
});

```
